#include "dungeon_header.h"
#include "text_tables.h"
#include "validation.h"
#include "help_menu.h"

void welcome()
/*
    accepts no arguments
    welcomes user to the game and explains the purpose of the game
    returns nothing
*/
{
    std::string pause;

    std::cout << "\t __          ________ _      _____ ____  __  __ ______\n"
            "\t \\ \\        / /  ____| |    / ____/ __ \\|  \\/  |  ____|\n"
            "\t  \\ \\  /\\  / /| |__  | |   | |   | |  | | \\  / | |__ \n"
            "\t   \\ \\/  \\/ / |  __| | |   | |   | |  | | |\\/| |  __|\n"
            "\t    \\  /\\  /  | |____| |___| |___| |__| | |  | | |____\n"
            "\t     \\/  \\/   |______|______\\_____\\____/|_|  |_|______|\n"
            "\t             | |        | | | |\n"
            "\t             | |_ ___   | |_| |__   ___\n"
            "\t             | __/ _ \\  | __| '_ \\ / _ \\\n"
            "\t             | || (_) | | |_| | | |  __/\n"
            "\t     _____  _ \\__\\___/ _ \\__|_| |_|\\___|___  _   _\n"
            "\t    |  __ \\| |  | | \\ | |/ ____|  ____/ __ \\| \\ | |\n"
            "\t    | |  | | |  | |  \\| | |  __| |__ | |  | |  \\| |\n"
            "\t    | |  | | |  | | . ` | | |_ |  __|| |  | | . ` |\n"
            "\t    | |__| | |__| | |\\  | |__| | |___| |__| | |\\  |\n"
            "\t    |_____/ \\____/|_| \\_|\\_____|______\\____/|_| \\_|\n\n";

// ascii art generated by http://patorjk.com/software/taag/
// formatting to output in c++ done personally

    std::cout << " This dungeon endeavors to evoke a sense of adventure and nostalgia reminiscent\n"
            " of the text based adventures of yore.  You are the hero.  Your purpose is to\n"
            " avoid death and collect treasure.  The story is regrettably lacking.  This is\n"
            " a roguelike game with a fixed quantity of floors for you to enjoy.\n"
            " Now that you understand the premise, let us be on our way!\n\n"
            " (Press enter to continue)";

    getline(std::cin, pause);
    starBar();
}

int selectDifficulty ()
/*
    accepts no arguments
    prompts user to select a difficulty level
    returns selected difficulty level
*/
{
    int difficulty;

    std::cout   << "\nPlease select your difficulty level. If you've never played before the tutorial\n"
                << "is highly recommended for explaining basic commands and mechanics. If you ever \n"
                << "need to review anything while exploring, just access our help menu by pressing H\n"
                << "\t" << TUTORIAL << ": Tutorial\n"
                << "\t" << EASY << ": Easy\n"
                << "\t" << NORMAL << ": Normal\n"
                << "\t" << HARD << ": Hard\n";

    difficulty = validInt(1,4);
    return difficulty;
}

int setBounds (int difficulty)
/*
    accepts the selected difficulty level
    determines through a simple switch the appropriate bounds for the game
    returns bounds
*/
{
     int bounds;

     switch (difficulty)
    {
        case TUTORIAL:
        {
            bounds = TUTORIAL_DIMENSION;
            break;
        }
        case EASY:
        {
            bounds = EASY_DIMENSION;
            break;
        }
        case NORMAL:
        {
            bounds = NORMAL_DIMENSION;
            break;
        }
        case HARD:
        {
            bounds = HARD_DIMENSION;
            break;
        }
    }

    return bounds;
}

void createTutorial (std::string dungeon[][MAX_SIZE][MAX_SIZE], int current_floor, int current_x, int current_y, int bounds)
/*
    accepts the dungeon (in reference form to permit modification), the current floor the player is exploring, the current position of the player, and the bounds for the dungeon
    creates a minimally randomized dungeon to introduce the basic game concepts to the player
    returns a populated dungeon through that reference we sent in
*/
{
    int         stairs_down = 1,
                treasure = 1,
                key = 1,
                traps = 1,
                small_rock = 1,
                boulder = 1,
                portal = 1;

    for (int x = 0; x < bounds; x++)
    {
        for (int y = 0; y < bounds; y++)
        {
            dungeon[current_floor][x][y] = EMPTY_SPACE;
        }
    }

    dungeon[current_floor][current_x][current_y] = PLAYER;
    // we have placed our player

    if (current_floor < bounds - 1)
    {
        placeObject(dungeon, current_floor, bounds, stairs_down, STAIRS_DOWN);
        // we have stairs to descend further into the dungeon unless we are on the final floor
    }

    if (current_floor == 0)
    {
        std::cin.ignore();
        aboutMovement();
        aboutStairs();
        std::cout << "\nWhy don't you try getting to the stairs on this floor?\n\n";
    }

    if (current_floor == 1)
    {
        placeObject(dungeon, current_floor, bounds, treasure, TREASURE);
        // we have placed our treasure

        placeObject(dungeon, current_floor, bounds, key, KEY);
        // we have placed our key

        std::cin.ignore();
        aboutTreasure();

        std::cout << "\nWhy don't you try getting the treasure from this floor?\n\n";

    }
    if (current_floor == 2)
    {
        placeObject(dungeon, current_floor, bounds, traps, TRAP);
        // we have placed our traps

        placeObject(dungeon, current_floor, (bounds - 1), small_rock, SMALL_BOULDER);
        // we have small rocks

        placeObject(dungeon, current_floor, bounds, boulder, LARGE_BOULDER);
        // we have boulders

        std::cin.ignore();
        aboutTraps();
        aboutBoulders();

        std::cout << "\nWhy don't you try disarming the trap on this floor?\n\n";
    }
    if (current_floor == (bounds - 1))
    {
        placeObject(dungeon, current_floor, bounds, portal, PORTAL);
        // we have our portal

        std::cin.ignore();
        aboutPortals();

        std::cout << "\nHead through the portal to finish this tutorial.\n\n";
    }
}

void createDungeon (std::string dungeon[][MAX_SIZE][MAX_SIZE], int current_floor, int current_x, int current_y, int difficulty, int bounds)
/*
    accepts the dungeon (in reference form to permit modification), the current floor the player is exploring, and the current position of the player.
    maintains current player position and randomly places traps and treasure, with some limitations
    returns a populated dungeon through that reference we sent in
*/
{

    int             stairs_down = 1,
                    portal = 1,
                    treasure,
                    key,
                    traps,
                    small_rock,
                    boulder;

    switch (difficulty)
    {
        case EASY:
        {
            treasure = 1;
            key = treasure;
            traps = current_floor + 1;
            small_rock = current_floor + 1;
            boulder = (current_floor + 1)/2;
            break;
        }
        case NORMAL:
        {
            treasure = 1 + (rand() % ((current_floor)+2));
            key = treasure;
            traps = 3 + (rand() % bounds + current_floor);
            if (current_floor < 4 && traps > 6)
            {
                traps /= 2;
            }
            small_rock = 2 +(rand() % traps);
            if (small_rock < 0)
            {
                small_rock = 3;
            }
            boulder = 1 + (rand() % bounds);
            break;
        }
        case HARD:
        {
            treasure = (rand() % (bounds + (current_floor)));
            key = (rand() % (treasure + 1));
            traps = 1 + (rand() % (bounds * (current_floor + 1))/2.5);
            small_rock = 2 * (2 +(rand() % traps)) / (current_floor + 1);
            boulder = (bounds * (current_floor + 2))/4;
            break;
        }
    }

    for (int x = 0; x < bounds; x++)
    {
        for (int y = 0; y < bounds; y++)
        {
            dungeon[current_floor][x][y] = EMPTY_SPACE;
        }
    }

    dungeon[current_floor][current_x][current_y] = PLAYER;
    // we have placed our player

    placeObject(dungeon, current_floor, bounds, treasure, TREASURE);
    // we have placed our treasure

    placeObject(dungeon, current_floor, bounds, key, KEY);
    // we have placed our key

    if (current_floor < (bounds - 1))
    {
        placeObject(dungeon, current_floor, bounds, stairs_down, STAIRS_DOWN);
        // we have stairs to descend further into the dungeon unless we are on the final floor
    }

    placeObject(dungeon, current_floor, bounds, traps, TRAP);
    // we have placed our traps

    placeObject(dungeon, current_floor, bounds, small_rock, SMALL_BOULDER);
    // we have small rocks

    placeObject(dungeon, current_floor, bounds, boulder, LARGE_BOULDER);

    if (current_floor == (bounds - 1))
    {
        placeObject(dungeon, current_floor, bounds, portal, PORTAL);
        // we have our exit portal
    }
}

void placeObject (std::string dungeon[][MAX_SIZE][MAX_SIZE], int current_floor, int bounds, int quantity_object, std::string target_object)
/*
    accepts the dungeon, the current floor, the bounds as determined by the difficulty level, the number of objects to be placed and the kind of object being placed
    places the designated quantity of the designated object within the designated bounds on the designated floor
    updates the dungeon via reference
*/
{

    int             x_axis,
                    y_axis;

    for (int i = 0; i < quantity_object; i++)
    {
        x_axis = (rand() % bounds);
        y_axis = (rand() % bounds);

        if (target_object != TREASURE &&
                   tooClose(dungeon, current_floor, bounds, x_axis, y_axis, TREASURE))
        {
            i--;
        } else if ( dungeon[current_floor][x_axis][y_axis] != EMPTY_SPACE ||
                    tooClose(dungeon, current_floor, bounds, x_axis, y_axis, PLAYER) ||
                    tooClose(dungeon, current_floor, bounds, x_axis, y_axis, STAIRS_DOWN) ||
                    tooClose(dungeon, current_floor, bounds, x_axis, y_axis, PORTAL))
        // if there's already something there, don't put a trap there, try again
        // if it's out of bounds, don't attempt to put a trap there, try again
        // if it's too close to the treasure (within 1 square), don't put a trap there, try again
        // if it's too close to the player's starting point, don't put a trap there, try again
        // the purpose of the buffer around player and treasure is to minimize the likelihood of an unwinnable game due to random generation
        {
            i--;
        }
        else
        {
            dungeon[current_floor][x_axis][y_axis] = target_object;
        }
    }
}

void displayDungeon (std::string dungeon[][MAX_SIZE][MAX_SIZE], int current_floor, int bounds)
/*
    accepts the dungeon and the current floor as parameters
    displays the current floor of the dungeon
    returns nothing
*/
{
    std::string grid_row = drawRow(bounds, bounds, GRID_SQUARE_LINE),
                perimeter = drawRow(bounds, bounds, PERIMETER_LINE);

    starBar();
    std::cout << "You are on level " << current_floor + 1 << " of the dungeon.\n";
    starBar();

    std::cout << perimeter;
    for (int x=0; x < bounds; x++)
    {
        std::cout << "|";
        for (int y=0; y < bounds; y++)
        {
            if (y == (bounds - 1))
            {
                std::cout << dungeon[current_floor][x][y] << "|";
            }
            else
            {
                std::cout << dungeon[current_floor][x][y] << " ";
            }
        }
        if (x == bounds - 1)
        {
            std::cout << "\n" << perimeter;
        }
        else
        {
            std::cout << "\n" << grid_row;
        }
    }
    std::cout   << "\nKey:    " << PLAYER << " = Hero    " << TRAP << " = Trap    " << TREASURE << " = Treasure    " << SMALL_BOULDER << " = Small Rock\n"
                << STAIRS_DOWN << " = Stairs Down    " << STAIRS_UP << " = Stairs Up\n\n";
}

std::string drawRow(int iterations, int bounds, std::string line_type)
/*
    generates string which displays a single row of the dungeon grid
    accepts the outer limits of the grid being generated and a string dictating what type of line is currently desired
    returns a string comprised of the appropriate number of repetitions of the string sent into the function to draw the line
*/
{
    std::string iAmLine;

    if ( iterations == 0 )
    {
        iAmLine += "\n";
    }
    else
    {
        if ( iterations == bounds)
        {
            iAmLine += "|";
        }
        iAmLine += line_type;
        iAmLine += drawRow(iterations - 1, bounds, line_type);
    }
    return iAmLine;
}

void currentInventory (int gold, int keys, int dynamite, bool boulder)
/*
    accepts the current quantity of various items the player has collected
    displays inventory
    returns nothing
*/
{
    std::cout << "You have " << gold << " gold";
    if (keys > 0)
    {
        std::cout << " and " << keys;
        if (keys == 1)
        {
            std::cout << " key";
        }
        else
        {
            std::cout << " keys";
        }
    }
    if (dynamite > 0)
    {
        std::cout << " and " << dynamite;
        if (dynamite == 1)
        {
            std::cout << " stick ";
        }
        else
        {
            std::cout << " sticks ";
        }
        std::cout << "of dynamite";
    }
    if (boulder)
    {
        std::cout << " and a boulder";
    }
    std::cout << ".\n\n";
}

bool checkMove (std::string dungeon[][MAX_SIZE][MAX_SIZE], int current_floor, int object_x, int object_y, int movement, std::string target_object)
/*
a) Input – the dungeon, object code you are checking for, move code
b) Function – check the move to see if onto a space containing the object code
c) Return – true if moved onto such a space
d) This function checks both for traps and finding treasure.
*/
{
    switch (movement)
    {
        case NORTH:
            if (dungeon[current_floor][object_x - 1][object_y] == target_object)
            {
                return true;
            }
            break;
        case WEST:
            if (dungeon[current_floor][object_x][object_y - 1] == target_object)
            {
                return true;
            }
            break;
        case SOUTH:
            if (dungeon[current_floor][object_x + 1][object_y] == target_object)
            {
                return true;
            }
            break;
        case EAST:
            if (dungeon[current_floor][object_x][object_y + 1] == target_object)
            {
                return true;
            }
            break;
        default:
            std::cout   << "I haven't the foggiest notion how you managed to get here, but you shouldn't have.\n"
                        << "Program will now terminate.\n";
            exit(EXIT_FAILURE);
            break;
    }
    return false;
}

void quitTime (bool &playing, bool &searching_floor)
/*
    accepts boolean control variables via reference
    sets control variables to false
    returns false values via reference
*/
{
    std::cout << "I'm sorry to see you leave.  Come play again soon!\n";

    searching_floor = false;
    playing = false;
}
